<?php

/**
* Ghost Captcha
*
* Ghost Captcha aims to minimize those annoying Captcha tests while still keeping out 
* spammers and their spambots. Using more user-friendly methods like the honeypot 
* technique and session timing, which work quietly in the background to identify any 
* suspicious activity typical of spambots. Only when suspicious activity is noticed is a
* captcha image loaded and the user forced to prove that they are human. Ghost Captcha 
* will also log IP addresses of suspected spambots and send regular emails reports to 
* the site administrator. 
* 
* Copyright (c) 2012, Patrick Jaoko
*
*
* @package GhostCaptcha
* @copyright Copyright (c) 2012, Patrick Jaoko
* @link http://pjtops.com/app/GhostCaptcha
* @version 1.0.0
*/


$config = array();
/*------------------------------------------------------------------------
// CONFIGURATION SETTINGS                                    
--------------------------------------------------------------------------


1. Application Paths
--------------------------------------------------------------------------

Cache Directory
Path to an EMPTY directory where captcha images and log files are saved. PHP must have 
write access to the folder. If it does not exist, the script will attempt to create it.
If left empty, it defaults to a folder named "cache" in the same directory as this file.
Example: /public_html/includes/Ghost-Captcha/cache
*/
$config['cacheDirectory'] = '';

/*
Cache URL
Web URL to the cache Directory above. The script will use this path to find and link to
captcha images whenever required.
Example: /Ghost-Captcha/cache/
*/
$config['cacheURL'] = '';



/* 
2. Captcha Timings & Template
--------------------------------------------------------------------------

Minimum Time
The minimum time in seconds, that a human is expected to download, fill and post back
a Websites' form. If they take a shorter time than this, they'll be logged as suspected
spambot, and the form will reload with a standard Captcha test.
*/
$config['timerMin'] = 10;

/*
Maximum Time
The minimum time in seconds, that a human is expected to download, fill and post back
a websites' form. If they take a longer than this, they'll be logged as suspected
spambot, and the form will reload with a standard Captcha test.
*/
$config['timerMax'] = 900;

/*
Captcha Template
This is a quick simple template for the Captcha field when it loads in a form. Adjust 
this if you require different HTML markup for your forms. The image field's src and 
class attributes must not be changed, as these are used by the script. The input field's
name attribute must also stay as is.
*/
$config['captchaTemplate'] = 
'<div class="ghostCaptcha" >
<b> Security Check </b><br />
Fill in all letters in the same order they appear in the image below.<br />
<img src="IMAGE_SRC" class="ghostCaptcha-image" /><br />
<input type="text" name="ghostCaptcha" value="" />
</div>';


/* 
3. Email Notifications
--------------------------------------------------------------------------

Admin Email
The email address to send email notifications to. Leaving this blank disables email 
notifications. The script logs the IP addresses of all suspected spambots, together with
 their form-filling speeds.
*/
$config['adminEmail'] = '';

/*
Log Size
The log size determines how often the email notifications are sent to the address above.
For example, setting it at fifty means an email will be sent containing the last fifty 
suspected spambot attack attempts. Setting it to 0 disables email notification.
*/
$config['logSize'] = 30;


/*
END OF CONFIGURATION SETTINGS                                 
--------------------------------------------------------------------------*/


class GhostCaptcha{

	protected static $adminEmail;
	protected static $logSize;	
	protected static $timerMin;
	protected static $timerMax;
	protected static $captchaTemplate;
	protected static $cacheDirectory = false;
	protected static $cacheURL = false;
	protected static $cache = null;
	public static $error;
	

/**
* Generates the hidden form fields to be used by Ghost Captcha, and sets matching form 
* variables. If this function is called through and Ajax request, a JSON object is sent 
* to the browser, otherwise this function returns a PHP string.
* 
* @param Number $timerMin The minimum time a human user is expected to take to fill and 
* 						  send back the form. If not set the value of self::$timerMin 
* 						  will be used instead.
* @param Number $timerMax The maximum time a human user is expected to take to fill & 
* 						  send back the form. If not set
* 						  the value of self::$timerMax will be used instead.
* @param String $jsForm   The form id, for forms set up through Ajax. If set, this will 
* 						  be a unique form id generated by the jQuery plugin.
* @return A PHP string or JSON object
*/	
	public static function set( $timerMin = false, $timerMax = false, $jsForm = false ){
		self::init();
		$commonFields = array('name','firstname','lastname','phone','address','email','city','date','message','postcode','country','surname',
							  'newsletter','company','age','position','month','year','username','surbub','state');
		$honeypot = $commonFields[ rand(0,20) ].'_'.self::randomString( rand(1,4) );
		$time = time();
		$output = array();
		
		if( $jsForm !== false && $_SERVER['REQUEST_METHOD'] === 'POST' ){
			$formId = $jsForm;
		}else if( isset($_POST['formId']) ){ 
			$formId = filter_var( $_POST['formId'], FILTER_SANITIZE_STRING );
		}else{
			$formId = floor( rand(1,10) * time() / 100 );
		}
		$output['formId'] = "<input type='hidden' name='formId' value='$formId' />";
		$output['honeypot'] = "<input name='$honeypot' value='' style='top:-999px; position:absolute;' />";		
		
		if( $_SERVER['REQUEST_METHOD'] === 'POST' && isset($_SESSION['ghostCaptcha'][$formId]) && self::validate() === false ){
			// if a form was posted, & the honeypot test failed, add the standard captcha test to the form, which should be resent
			$cache = self::getCache();
			$_SESSION['ghostCaptcha'][$formId]['imgText'] = $cache['selected']['imgText'];
			$output['captcha'] = str_replace( 'IMAGE_SRC', $cache['selected']['imgURL'], self::$captchaTemplate );
		}else {
			$_SESSION['ghostCaptcha'][$formId] = array( 'formId'=>$formId, 'ajax'=>false );
		}
		$_SESSION['ghostCaptcha'][$formId]['startTime'] = $time;
		$_SESSION['ghostCaptcha'][$formId]['honeypot'] = $honeypot;
		
		if( $timerMin !== false ){ $_SESSION['ghostCaptcha'][$formId]['timerMin'] = $timerMin; }
		if( $timerMax !== false ){ $_SESSION['ghostCaptcha'][$formId]['timerMax'] = $timerMax; }
		
		if( $jsForm ){
			$_SESSION['ghostCaptcha'][$formId]['ajax'] = true;
			$cache = self::getCache();
			$output['captcha'] = str_replace( 'IMAGE_SRC', $cache['selected']['imgURL'], self::$captchaTemplate );
			$output['imgURLs'] = $cache['imgURLs'];
			self::renderJSON($output);
		}else {		
			$output = implode( "\n", $output );	
			return $output;	
		}
	}	

/**
* Determines if the sender is human or a spambot, by analyzing the last form post's 
* contents and timing
* 
* @return Boolean Returns true for humans, and false for spambots.
*/
	public static function validate(){ 
		self::init();
		self::$error = array();
		
		$formId = ( isset($_POST['formId']) )? filter_var( $_POST['formId'], FILTER_SANITIZE_STRING ) : false; 
		$formSession = ( $formId && isset($_SESSION['ghostCaptcha'][$formId]) )? $_SESSION['ghostCaptcha'][$formId] : false;
		$failReason = false;
		$isHuman = false;
		
		if( $formSession && isset( $_POST[$formSession['honeypot']] ) ){ 
			$honeypot  = $formSession['honeypot'];
			$time = (time() - $formSession['startTime']);			
			
			$timerMin = ( isset($formSession['timerMin']) )? $formSession['timerMin'] : self::$timerMin;
			$timerMax = ( isset($formSession['timerMax']) )? $formSession['timerMax'] : self::$timerMax;
			
			if( $_POST[$honeypot] !== '' ){
				$failReason = 'honeypot trap filled';
			}else if( $time < $timerMin ){
				$failReason = 'form filled too fast';
			}else if( $time > $timerMax ){
				$failReason = 'form filled too slow';
			}		
			
			if( !$failReason ){
				// the form was filled within the set min & max time, and the honeypot trap is empty
				$isHuman = true; 

				if( isset($formSession['imgText']) ){ 
					// the user was also asked to solve a captcha due to suspiciuos behaviour
					if( !isset($_POST['ghostCaptcha']) || $_POST['ghostCaptcha'] !== $formSession['imgText'] ){
						$isHuman = false;
						$failReason = 'wrong captcha answer';
					}
				}				
			}else if( $formSession['ajax'] && $_POST[$honeypot] !== '' && isset($_POST['ghostCaptcha']) ){
				// captcha test was set up using ajax/javascript. The user was also asked to solve a captcha due to suspiciuos behaviour.
				// The jQuery plugin will automatically fill the honeypot field with the captcha images URL whenever the captcha test is triggered
				$imgURL = $_POST[$honeypot];
				$cache = self::getCache();
				
				if( $imgText = array_keys( $cache['images'], $_POST[$honeypot] ) ){
					$imgText = $imgText[0];
					if( $imgText === $_POST['ghostCaptcha'] ){
						$isHuman = true;
					}else {
						$failReason = 'wrong captcha answer';						
					}
				}
			}
		}
		
		if( $isHuman == false && $_SERVER['REQUEST_METHOD'] === 'POST' ){
			$cache = self::getCache();
			$logs = $cache['logs'];
			self::$error['ip'] = $_SERVER["REMOTE_ADDR"];
			self::$error['date'] = date('F j, Y');
			self::$error['reason'] = ( !$failReason )? 'missing form fields' : $failReason;
			$cache['logs'][] = 'IP Address: '.self::$error['ip'].', Date: '.self::$error['date'].', Reason: '.self::$error['reason'];
			self::setCache($cache);
			$logCount = count($cache['logs']);
						
			if( self::$adminEmail && self::$logSize > 0 &&  $logCount >= self::$logSize ){
				//email notification is enabled, and the set number of suspected spambot logs has been reached
				$subject = 'Ghost Captcha: Generated Report';				
				$headers = array();
				$headers[] = "From: ".self::$adminEmail;
				$headers[] = "Content-type: text/plain; charset=iso-8859-1";
				$headers = implode( "\r\n", $headers );				
				$message = "This is an autogenerated report, listing all recent form posts received from suspected spambots. \n";				
				$message .= "You can set if, and how often this message is sent by editing your Ghost Captcha script's configuration settings.\n\n";
				$message .= implode( "\r\n", $cache['logs'] );					
				mail( self::$adminEmail, $subject, $message, $headers );
				
				$cache['logs'] = array();
				self::buildCache();
			}else if( self::$logSize == 0 && $logCount > 30 ){
				//email notification turned off. Rebuild cache to generate new captcha images
				self::buildCache();				
			}			
		}
			
		return $isHuman;
	}
	
/**
* Loads all the configuration settings, and initializes class properties.
* @throws Throws an exception if the set configuration directory is not writable.
*/	
	protected static function init( ){
		global $config; 
		if( session_id() == ''){
			
		}
		if( !isset($_SESSION['ghostCaptcha']) ){
			$_SESSION['ghostCaptcha'] = array();			
		}
		
		if( self::$cacheDirectory == false || self::$cacheURL == false ){
			
			$path = str_replace( "\\", '/', dirname(__FILE__).'/cache/' );
			if( !$config['cacheDirectory'] ){
				self::$cacheDirectory = $path;
			}
			if( !$config['cacheURL'] ){
				$url = str_replace( "\\", '/', rtrim( $_SERVER['DOCUMENT_ROOT'], '/' ));
				self::$cacheURL = substr( $path, strlen($url) );
			}
			if( !is_dir(self::$cacheDirectory) ){
					self::buildCache();
			}
			
			self::$adminEmail = $config['adminEmail'];
			self::$logSize = $config['logSize'];
			self::$timerMin = $config['timerMin'];
			self::$timerMax = $config['timerMax'];
			self::$captchaTemplate = $config['captchaTemplate'];			
		}
	}

/**
* Generates a random string, for use in form fields and image names
* @param  Number $size The length of the generated string
* @return String The generated string
*/	
	protected static function randomString( $size ){
		$characters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
		$output = '';
		for( $i = 0; $i < $size; $i++ ){
			$output .= $characters[ rand( 0, strlen($characters) - 1) ];
		}
		return 	$output;		
	}

/**
* Parses the cache file, and returns an object representing cached items, which include 
* activity logs and the paths and details of cached captcha images.
* 
* @return Array An array with the following keys: images, selected, imgURLs
*/	
	protected static function getCache(){
		if( self::$cache ){
			return self::$cache; 
		}		
		
		// check if cache is set & valid
		$cacheFile = self::$cacheDirectory.'/'.'cache.php';
		$cache = false;
		if( is_file($cacheFile) ){
			$cache = unserialize(file_get_contents($cacheFile));
		}
		if( !$cache ){
			$cache = self::buildCache();
		}
		
		$selected = rand( 0, 15 );
		$images = array();
		$i = 0;
		foreach( $cache['images'] as $key => $value ){
			if( $i == $selected ){
				$cache['selected'] = array( 'imgText'=>$key, 'imgURL'=>$value );
			}else {
				$imgURLs[] = $value;
			}
			$i++;
		}
		
		shuffle($imgURLs);
		$cache['imgURLs'] = array_slice( $imgURLs, 0, 8 );		
		return $cache;
	}

/**
* Save the current state of the cache as a serialized string to file. 
* @param Array $cache The cache object
*/	
	protected static function setCache( $cache ){		
		$fh = fopen( self::$cacheDirectory.'cache.php', 'w' );
		fwrite( $fh, serialize($cache) );	
		fclose($fh);		
	}

/**
* Build the GhostCaptcha cache, which temporarily stores generated captcha images and 
* the activity logs used for email notifications.
*/	
	protected static function buildCache(){ 
		self::$cache = null;
		if( !is_dir(self::$cacheDirectory) ){
			mkdir(self::$cacheDirectory);
			@chmod( self::$cacheDirectory, 0770 );
		}else if( !is_writable(self::$cacheDirectory) ){
			throw new Exception('The Ghost Captcha directory ('.self::$cacheDirectory.') is not writable.');
		}
		
		$files = array_diff( scandir(self::$cacheDirectory), array( '..', '.' ) );
		foreach( $files as $file ){
			unlink( self::$cacheDirectory.$file );				
		}
		
		$cache = array( 'logs'=> array(), 'images'=> array() );		
		
		$img = ImageCreate( 50, 50 );
		$textColor = ImageColorAllocate( $img, 200, 200, 200 );
		$customFont = ( function_exists('imagettftext') && imagettftext( $img, 12, 0, 10, 10, $textColor, 'captcha-font.ttf', 'A' ) );
		ImageDestroy($img);
		
		for( $i=0; $i < 16; $i++ ){
			$image = self::randomString( rand(5,8) ).'.jpg';
			$imgURL = self::$cacheURL.$image;
			$imgText = self::randomString( rand(5,6) );
			$cache['images'][$imgText] = $imgURL;
			
			$imgPath = self::$cacheDirectory.$image;
			$imgWidth = strlen($imgText) * 30;
			$imgHeight = 60;
			$img = ImageCreate( $imgWidth, $imgHeight );

			// colors
			$backColor = ImageColorAllocate( $img, 0, 0, 32 );
			$textColor = ImageColorAllocate( $img, 200, 200, 200 );
			$lineColor = ImageColorAllocate( $img, 100, 100, 100 );

			$bg = imagecreatefromjpeg('captcha-bg.jpg');
			imagesettile( $img, $bg );
			imagefill( $img, 0, 0, IMG_COLOR_TILED );
			
			for( $j = 0; $j < $imgWidth; $j += 20 ){
				$x1 = rand( $j, $j + 10 );
				$x2 = rand( $j, $j + 10 );
				ImageLine( $img, $x1, 0, $x2, $imgHeight, $lineColor ); // vertical lines
			}
			for( $j = 0; $j < $imgHeight; $j += 20 ){
				$y1 = rand( $j, $j + 10 );
				$y2 = rand( $j, $j + 10 );
				ImageLine( $img, 0, $y1, $imgWidth, $y2 , $lineColor ); //horizontal lines
			}

			$imgText = str_split($imgText);
			$x1 = 15;
			foreach( $imgText as $j => $letter ){
				if( $customFont ){
					$fontSize = rand( 12, 24 );
					$y1 = rand( 30, 40 );
					imagettftext( $img, $fontSize, rand( -30, 30), $x1, $y1, $textColor, 'captcha-font.ttf', $letter);
					$x1 += rand( 5, 10 ) + $fontSize;
				}else {
					$y1 = rand( 10, 40 );
					ImageString( $img, 5, $x1, $y1, $letter, $textColor );
					$x1 += rand( 15, 30 );
				}
			}

			imagejpeg( $img, $imgPath, 75 );
			ImageDestroy($img);				
		}
		self::setcache($cache);		
		
		return $cache;
	}
	
	static protected function renderJSON( $output ){
		header('Cache-Control: no-cache, must-revalidate');
		header('Expires: Thu, 1 Nov 2012 12:00:00 GMT');
		header('Content-type: application/json');
		$output = json_encode($output);
		echo $output;
		exit;
	}
}

if( isset($_POST['jsSetRequest']) && isset($_POST['formId']) ){
	// its an ajax request
	GhostCaptcha::set( false, false, $_POST['formId'] );	
}